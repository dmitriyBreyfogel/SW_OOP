# OOP код-ревью

## Ключевые замечания

- **Смешение ролей в `GameModel`**: класс одновременно отвечает за жизненный цикл партии, создание игроков, выбор их меток и работу фабрик (`CellFactory`, `LabelFactory`), из-за чего нарушается принцип единственной ответственности. Прямые вызовы конструкторов игроков и фабрик внутри конструктора (`GameModel()` строки 45-63) и метода `generateField()` (строки 68-77) затрудняют тестирование и замену стратегий. Лучше ввести зависимости через конструктор/интерфейсы (например, `PlayerFactory`, `FieldInitializer`) и отдельные сервисы для подсчёта победы и лимитов пасов.【F:src/xzero/model/GameModel.java†L45-L77】

- **Хрупкое управление состоянием активного игрока**: методы `start()`, `exchangePlayer()` и `passTurn()` вручную манипулируют индексом `_activePlayer` (строки 80-123), дублируя логику перехода хода. Отсутствуют инварианты и явная стратегия очередности игроков. Предлагается инкапсулировать выбор следующего игрока в отдельном объекте (например, `TurnOrder`), который хранит лимиты пасов и умеет безопасно переключать активного игрока, избегая ручных ++/мод-операций.【F:src/xzero/model/GameModel.java†L80-L123】

- **Неполная инкапсуляция поля и ячеек**: `GameField` хранит клетки в списке и ищет их линейным перебором (`cell()` строки 19-25), что усложняет гарантии уникальности координат и масштабирование. Нет защитного копирования координат при `setCell` (строки 28-35), поэтому внешние изменения `Point` могут нарушить инварианты. Стоит использовать карту `Map<Point, Cell>` с неизменяемыми ключами либо собственный value-объект позиции и выполнять защитное копирование при установке клетки.【F:src/xzero/model/GameField.java†L19-L35】

- **Нарушение симметрии двусторонних связей**: `Cell.setPosition` и `setField` (строки 14-23) записывают ссылки без проверок и без уведомления `GameField`. При этом `GameField.setCell` не проверяет, что ячейка ранее не принадлежала другому полю. Для корректного агрегирования следует сделать `Cell` неизменяемо привязанной к полю и позиции через конструктор либо предоставить фабрику, которая создаёт полностью проинициализированные ячейки, гарантируя, что одна ячейка не «мигрирует» между полями.【F:src/xzero/model/Cell.java†L14-L23】【F:src/xzero/model/GameField.java†L28-L35】

- **Недостаточная типобезопасность событий**: коллекции слушателей в `GameModel` объявлены как «сырой» `ArrayList` без дженериков (`_listenerList`, `_playerListenerList`, строки 221-238 и 90-123 соответственно), что маскирует ошибки типов и требует ручных приведений. Использование параметризованных списков (`List<GameListener>`, `List<PlayerActionListener>`) устранит касты и улучшит читаемость. Аналогично, стоит инкапсулировать логику уведомлений в отдельные классы, чтобы `GameModel` не совмещал бизнес-логику и инфраструктурный код событий.【F:src/xzero/model/GameModel.java†L90-L123】【F:src/xzero/model/GameModel.java†L221-L238】

- **Общая связность игроков и меток**: `Player` напрямую оперирует полем `GameField` и списком собственных меток (строки 27-83), что делает его одновременно актором и хранилищем состояния поля. Рекомендуется выделить интерфейс для взаимодействия с игровым полем (например, `Board`), а подсчёт меток игрока вынести в сервис или запрос поля, чтобы игрок отвечал лишь за выбор хода и реакции на события. Кроме того, методы `takeActiveLabel` и `setLabelTo` бросают одинаковые исключения с текстом «метка не может быть null», хотя нарушение связано с порядком вызовов; лучше использовать более точные типы/сообщения и предусмотреть состояние «нет активной метки» без исключений (через Optional или шаблон «Команда»).【F:src/xzero/model/Player.java†L27-L83】

- **Расширяемость типов меток**: `GameModel` и `Player` завязаны на конкретный `LabelType` и `LabelFactory` (строки 90-143), но нет полиморфного интерфейса для разных правил размещения/выигрыша. Введение стратегий победы (`WinCondition`), стратегий генерации меток и, возможно, паттерна «Состояние» для смены режима активной метки позволило бы добавить новые типы без модификации существующих классов (принцип открытости/закрытости).【F:src/xzero/model/GameModel.java†L90-L143】

## Положительные моменты

- В `Cell.placeLabel`/`removeLabel` соблюдена двусторонняя консистентность между клеткой и меткой, что предотвращает рассинхронизацию состояния при перемещении меток по полю.【F:src/xzero/model/Cell.java†L27-L47】
- Защитная копия позиции в `Cell.position()` не даёт внешнему коду менять внутреннее состояние клетки напрямую, что помогает поддерживать инварианты координат в тестах.【F:src/xzero/model/Cell.java†L17-L21】

## Итог

Архитектура отражает базовые принципы (инкапсуляция состояний клеток и меток, событийная модель), но остаются существенные точки роста: разделение ответственности в `GameModel`, чёткие агрегаты для поля/ячеек, типобезопасные коллекции и стратегии для расширения правил игры. Внесение этих изменений сделает проект ближе к «эталону» объектно-ориентированного дизайна.
